# -*- coding: utf-8 -*-
"""OnlineRetail_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zI3HmO7Pv8Z2DWKzH0d3bINBtEvgBuUO

# ONLINE RETAIL II

####Business Problem :
1. Bagaimana memisakan pelaanggan untuk promosi yang tepat ?
    <p>Melakukan metode Clustering (Pengelompokkan) berdasarkan Recency, Frequency, Monetary ( RFM ). Model ini merupakan proses penilaian berdasarkan perilaku pelanggan yang akan dilihat dari waktu transaksi terakhir pelanggan (Recency), jumlah transaksi
(Frequency), dan uang yang dikeluarkan (Monetary). </p>

2. Bagaimana cara untuk meningkatkan volume penjualan pelanggan ?   

*   Membuat tabel cohort analytics berdasarkan kepuasan pelanggan untuk mengetahui tingkat pembelian pelanggan
*   mengetahui tingkat pembelian pelanggan
*   Membuat Market Basket Analytics (Menggabungkan barang) sehingga meningkatkan penjualan barang
*  Membuat Rekomendasi Produk
"""

# upload files ke lembar kerja
from google.colab import files
files.upload()

# Commented out IPython magic to ensure Python compatibility.
# import modul yang dibutuhkan
import pandas as pd
import numpy as np
import seaborn as sns
from datetime import datetime, timedelta
import datetime as dt
# %matplotlib inline
import matplotlib.pyplot as plt
from mlxtend.frequent_patterns import apriori
from mlxtend.frequent_patterns import association_rules
sns.set_style("darkgrid")
import warnings
warnings.filterwarnings('ignore')
from scipy import stats
from scipy.stats import norm
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

"""# DATA UNDERSTANDING"""

# read data online retail
data = pd.read_csv('online_retail_II.csv', encoding='latin1')
data.head(10)

"""#### Deskripsi singkat:
1.   InvoiceNo : Nomor faktur, jika nomor dimulai dengan huruf "c" artinya terjadi pembatalan transaksi.
2.   StockCode : Kode produk 
3. Description : Nama produk / item
4. Quantity : jumlah produk tiap transaksi
5. InvoiceDate : Tanggal dan waktu traksanksi.
6.  Price : Harga satuan / harga produk per unit.
7. Costumer ID : Nomor id pelanggan.
8. Country : Nama negara asal pelanggan.

"""

# info tentang data
data.info()

# deskripsi data
data.describe()

# ukuran data
data.shape

"""# DATA PREPARATION

### FORMATING DATA
Buat kolom baru yang berisi status dari transaksi (Invoice) yaitu Status_invoice, dimana jika dalam Invoice mengandung huruf C didalamnya maka status traksaksinya batal (Failed) dan juka Invoice tidak mengandung huruf C didalamnya maka transaksinya berstatus sukses (Sukses)
"""

# buat kolom baru Status_invoice
data.loc[data['Invoice'].str.contains('C',na=False),'Status_invoice'] = 'Failed'
data.loc[~(data['Invoice'].str.contains('C',na=False)),'Status_invoice'] = 'Success'
data.head(3)

"""Cek apakah terdapat data duplikasi pada kolom StockCode, karena dalam setiap 1 jenis nama barang (Description) hanya memiliki 1 kode stok (StockCode). Apabila dalam satu kode barang (StockCode) terdapat lebih dari 1 nama barang yang tertera, maka hal tersebut mengindikasikan telah terjadi duplikasi.
<p>Oleh karena itu, dibuatlah kolom baru yang berisi deskripsi tentang apakah barang tersebut merupakan barang dupikasi atau tidak. jika barang tersebut adalah barang dupilkasi maka barang tersebut berstatus "Duplicate", jika tdak maka akan berstatus "Unduplicate".</p>
"""

# cek unique pada StockCode dengan membuat dataframe baru yaitu data_StockCode
data_StockCode = data.groupby(['StockCode']).agg({'Description':'nunique'}).reset_index()
data_StockCode

# buat kolom baru desc_stockcode
data_StockCode.loc[data_StockCode['Description'] > 1, 'desc_stockcode'] = 'Duplicated'
data_StockCode.loc[~(data_StockCode['Description'] > 1), 'desc_stockcode'] = 'Unduplicated'

# simpan data deskripsi tentang Kode Stok
data_StockCode.to_csv('data_StockCode.csv', index=False)

# Cek data_StockCode
data_StockCode.head(3)

# buat array yang berisi data StockCode beserta deskripsinya yaitu desc_stockcode 
desc_stockcode = dict(zip(data_StockCode['StockCode'], data_StockCode['desc_stockcode']))

# buat kolom baru desc_stockcode kedalam data yang berisi deskripsi dari tiap StockCode 
data['desc_stockcode'] = data['StockCode'].map(desc_stockcode)

# recek data
data.head(5)

"""Buat kolom baru yaitu transaction_date yang hanya berisi data tahun, bulan dan tanggal transaksi."""

# buat kolom tahun transaksi yaitu year
data['year'] = data['InvoiceDate'].str[:4]

# buat kolom bulan transaksi yaitu month
data['month'] = data['InvoiceDate'].str[5:7]

# buat kolom tanggal transaksi yaitu day
data['day'] = data['InvoiceDate'].str[8:10]

# buat kolom jam transaksi yaitu day
data['hour'] = data['InvoiceDate'].str[11:13]

# formating data waktu transaksi
data['InvoiceDate'] = pd.to_datetime(data['InvoiceDate'],format='%Y-%m-%d %H:%M')

# waktu transaksi terakhir
max_date = max(data['InvoiceDate'])

# buat kolom baru yang berisi selisi waktu dalam transaksi
data['time_difference'] = max_date - data['InvoiceDate']

# cek data
data.head(5)

"""Buat kolom baru yaitu kolom penjualan (sales) yang berisi perkalian antara Price dan Quantity"""

# buat kolom baru sales
data['sales'] = data['Price'] * data['Quantity']

# tampilkan kolom sales
data['sales'].head(3)

# ubah tipe data Costumer ID
data['Customer ID'] = data['Customer ID'].astype(str)

# ambil waktu transaksi terakhir dalam ukuran hari
data['time_difference'] = data['time_difference'].dt.days

# ubah type data time_difference ke integer
data['time_difference'] = data['time_difference'].astype(int)

# simpan data yang telah ditambahkan beberapa kolom
data.to_csv('Preparation_Online Retail.scv', index=False)

# cek ukuran data
data.shape

# data Quantity yang bernilai negatif
data['Quantity'][data['Quantity']<0]

# data Quantity yang bernilai negatif
len(data['Quantity'][data['Quantity']<0])

"""# DATA CLEANSING"""

# tampilkan data
data.head(5)

# cek kolom yang memiliki missing value
data.isnull().sum()[data.isnull().sum()>=0]

# persentase kolom yang memiliki missing value
missing = round(100*((data.isnull().sum())/len(data)), 2)
missing

# cek ukuran data
data.shape

# Hapus data missing value
data = data.dropna()

# recek ukuran data
data.shape

"""#VISUALISASI DATA"""

# tampilkan data
data.head(3)

# cek nama dari setiap kolom data
data.columns

"""###Invoice"""

# total transaksi
print('Total transaksi : ', len(data['Invoice']))

# banyaknya transaksi yang sukses dan gagal pada tahun 2009 - 2011
data['Invoice'].groupby(data['Status_invoice']).agg('count').sort_values(ascending = False).head(5)

# plot banyaknya transaksi yang sukses dan gagal
a = data['Invoice'].groupby(data['Status_invoice']).agg('count').sort_values(ascending = False)
sns.barplot(x = a.values, y = a.index, palette = 'inferno')
plt.title('Deskripsi Transaksi', fontsize = 20)
plt.xlabel('Status')
plt.ylabel('Jumlah')
plt.show()

"""Banyaknya transaksi yang sukse sebanyak 805620 dan transaksi yang gagal sebanyak 18744

### StocCode
"""

# banyak kode barang
print('Banyak kode barang : ',len(data['StockCode'].unique()))

# 5 kode barang dengan frekuensi transaksi terbesar
data['StockCode'].value_counts().head(5)

# cek plot 5 kode barang dengan frekuensi transaksi terbesar
plt.rcParams['figure.figsize']=(12, 3)
code = data['StockCode'].value_counts().head(5)
sns.barplot(x=code.values, y=code.index, palette = 'inferno')
plt.title('5 Kode barang dengan frekuensi terbesar')
plt.ylabel('Kode Barang')
plt.xlabel('Frequensi')
plt.show()

# 5 kode barang dengan frekuensi transaksi terkecil
data['StockCode'].value_counts().tail(5)

# cek plot 5 kode barang dengan frekuensi transaksi tekecil
plt.rcParams['figure.figsize']=(12, 3)
code = data['StockCode'].value_counts().tail(5)
sns.barplot(x=code.values, y=code.index, palette = 'inferno')
plt.title('5 Kode barang dengan frekuensi terbesar')
plt.ylabel('Kode Barang')
plt.xlabel('Frequensi')
plt.show()

"""Dapat dilihat bahwa Kode barang (StockCode) dengan frekuensi terbesar yaitu barang dengan kode 85123A dengan frekuensi sebesar 5322 dan kode barang dengan frekuensi terkecil yaitu barang dengan kode 35974, 21053, 35822P, 90025B dan 90011C dengan frekuensi yang sama sebesar 1."""

# 5 trnsaksi dengan kode barang tertentu dengan kuantitas terbesar
data['Quantity'].groupby(data['StockCode']).agg('sum').sort_values(ascending = False).head(5)

# 5 barang dengan kode tertentu dengan kuantitas terkecil
data['Quantity'].groupby(data['StockCode']).agg('sum').sort_values(ascending = False).tail(5)

"""### Quantity"""

# jumlah transaksi barang dengan status sukses dan gagal
data['Quantity'].groupby(data['Status_invoice']).agg('sum').sort_values(ascending = False)

# 5 negara yang melakukan transaksi dengan kuantitas terbesar
data['Quantity'].groupby(data['Country']).agg('sum').sort_values(ascending = False).head(5)

# 5 negara yang melakukan transaksi dengan kuantitas terbesar
data['Quantity'].groupby(data['Country']).agg('sum').sort_values(ascending = False).head(5).plot.bar(figsize = (6, 4))

# 5 negara yang melakukan transaksi dengan kuantitas terkecil
data['Quantity'].groupby(data['Country']).agg('sum').sort_values(ascending = False).tail(5)

# 5 negara yang melakukan transaksi dengan kuantitas terkecil
data['Quantity'].groupby(data['Country']).agg('sum').sort_values(ascending = False).tail(5).plot.bar(figsize = (6, 4))

"""Dapat dilihat bahwa negara yang melakukan transaksi dengan kuantitas terbesar yaitu negara United Kingdon dengan kuantitas sebesar 8353502 dan yang terkecil adalah negara Saidi Arabia dengan kuantitas sebesar 75."""

# jumlah transaksi yang dilakukan pada tahun 2009-2011
data['Quantity'].groupby(data['year']).agg('sum').sort_values(ascending = False)

# kuantitas transaksi yang dilakukan pada tahun 2009-2011
data['Quantity'].groupby(data['year']).agg('sum').sort_values(ascending = False).plot.bar(figsize = (6, 4))

"""Dapat dilihat bahwa kuantitas transaksi yang dilakukan mulai tahun 2009 - 2011 mengalami pemingkatan, terutama pada tahun 2009 dan 2010

### Price
"""

# tampilkan data
data.head(3)

# deskripsi kolom price
data['Price'].describe()

# 5 kode barang dengan harga tertinggi
data['Price'].groupby(data['StockCode']).agg('sum').sort_values(ascending = False).head(5)

# 5 kode barang dengan harga terendah
data['Price'].groupby(data['StockCode']).agg('sum').sort_values(ascending = False).tail(5)

"""Dapat dilihat bahwa kode barang yang memiliki harga tertinggi yaitu barang dengan kode M dan dengan harga 476376.17, sedangkan kode barang dengan harga terendah yaitu barang dengan kode 17061 dengan harga 0.4

### CostumerID
"""

# frekuensi dari berbagai Costumer ID dalam melakukan transaksi
frequency=data['Invoice'].groupby(data['Customer ID']).agg('count')
frequency = frequency.reset_index()
frequency.columns = ['Customer ID', 'Frequency']
frequency

# 5 frekuensi terbesar dari berbagai Costumer ID dalam melakukan transaksi
frequency=data['Invoice'].groupby(data['Customer ID']).agg('count').sort_values(ascending = False)
frequency = frequency.reset_index()
frequency.columns = ['Customer ID', 'Frequency']
frequency.head(5)

# plot 5 frekuensi terbesar dari berbagai Costumer ID dalam melakukan transaksi
data['Invoice'].groupby(data['Customer ID']).agg('count').sort_values(ascending = False).head(5).plot.bar(figsize=(12, 4))

# 5 frekuensi terkecil dari berbagai Costumer ID dalam melakukan transaksi
frequency=data['Invoice'].groupby(data['Customer ID']).agg('count').sort_values(ascending = False)
frequency = frequency.reset_index()
frequency.columns = ['Customer ID', 'Frequency']
frequency.tail(5)

# plot 5 frekuensi terkecil dari berbagai Costumer ID dalam melakukan transaksi
data['Invoice'].groupby(data['Customer ID']).agg('count').sort_values(ascending = False).tail(5).plot.bar(figsize=(12, 4))

"""Dapat dilihat bahwa Costumer ID yang memiliki frekuensi transaksi terbanyak yaitu costumer dengan nomor id 17841 dengan transaksi sebanayak 13097 dan terdapat 5 costumer yang memiliki frekuensi transaksi terkecil yaitu 13205.0, 13215.0, 15893.0, 13222.0, 15316.0 dengan transaksi sebanayak 1 kali."""

# total pengeluaran dari setiap costumer dalam melakukan transaksi
amount=data['sales'].groupby(data['Customer ID']).agg('sum')
amount = amount.reset_index()
amount.columns = ['Customer ID', 'Total pengeluaran']
amount

# 5 costumer yang melakukan transaksi dengan nilai pengeluaran terbesar
amount=data['sales'].groupby(data['Customer ID']).agg('sum').sort_values(ascending = False)
amount = amount.reset_index()
amount.columns = ['Customer ID', 'Total pengeluaran']
amount.head(5)

# 5 costumer yang melakukan transaksi dengan nilai pengeluaran terbesar
amount=data['sales'].groupby(data['Customer ID']).agg('sum').sort_values(ascending = False)
amount = amount.reset_index()
amount.columns = ['Customer ID', 'Total pengeluaran']
amount.tail(5)

# 5 costumer yang melakukan transaksi dengan nilai pengeluaran terbesar
time=delta=data['time_difference'].groupby(data['Customer ID']).agg('min')
time = time.reset_index()
time.columns = ['Customer ID', 'Waktu Terakhir Transaksi']
time

# 5 costumer yang melakukan transaksi terakhir paling lama
time=delta=data['time_difference'].groupby(data['Customer ID']).agg('min').sort_values(ascending = False)
time = time.reset_index()
time.columns = ['Customer ID', 'Waktu Terakhir Transaksi']
time.head(5)

# 5 costumer yang melakukan transaksi terakhir baru saja 
time=delta=data['time_difference'].groupby(data['Customer ID']).agg('min').sort_values(ascending = False)
time = time.reset_index()
time.columns = ['Customer ID', 'Waktu Terakhir Transaksi']
time.tail(5)

"""### Country"""

# Frekuensi tiap negara melakukan transaksi
frequency=data['Invoice'].groupby(data['Country']).agg('count')
frequency = frequency.reset_index()
frequency.columns = ['Country', 'Frequency']
frequency

# 5 Negara yang melakukan transaksi terbanyak
frequency=data['Invoice'].groupby(data['Country']).agg('count').sort_values(ascending = False)
frequency = frequency.reset_index()
frequency.columns = ['Country', 'Frequency']
frequency.head(5)

# 5 Negara yang melakukan transaksi terkecil
frequency=data['Invoice'].groupby(data['Country']).agg('count').sort_values(ascending = False)
frequency = frequency.reset_index()
frequency.columns = ['Country', 'Frequency']
frequency.tail(5)

# pengeluaran tiap negara dalam melakukan transaksi
amount=data['sales'].groupby(data['Country']).agg('count')
amount = amount.reset_index()
amount.columns = ['Country', 'Total Pengeluaran']
amount

# 5 Negara dengan transaksi total pengeluaran terbesar
amount=data['sales'].groupby(data['Country']).agg('count').sort_values(ascending = False)
amount = amount.reset_index()
amount.columns = ['Country', 'Total Pengeluaran']
amount.head(5)

# 5 Negara dengan transaksi total pengeluaran terkecil
amount=data['sales'].groupby(data['Country']).agg('count').sort_values(ascending = False)
amount = amount.reset_index()
amount.columns = ['Country', 'Total Pengeluaran']
amount.tail(5)

# Daftar waktu terakhir transaksi setiap negara
time=data['time_difference'].groupby(data['Country']).agg('min')
time = time.reset_index()
time.columns = ['Country', 'Waktu Terakhir Transaksi']
time

# 5 Negara dengan waktu transaksi teraksi terlama
time=data['time_difference'].groupby(data['Country']).agg('min').sort_values(ascending = False)
time = time.reset_index()
time.columns = ['Country', 'Waktu Terakhir Transaksi']
time.head(5)

# 5 Negara dengan waktu transaksi teraksi terbaru (tercepat)
time=data['time_difference'].groupby(data['Country']).agg('min').sort_values(ascending = False)
time = time.reset_index()
time.columns = ['Country', 'Waktu Terakhir Transaksi']
time.tail(5)

"""### Status_invoice"""

data.head(3)

# jumlah ttransaksi yang berstatus sukses dan gagal
frequency=data['Status_invoice'].value_counts().reset_index()
frequency.columns=['Status', 'Frequency']
frequency

# daftar tiat transaksi yang berasal dari berbagai negara yang berstatus 
status = data['Status_invoice'].groupby(data['Country']).agg('value_counts').unstack().reset_index()
status

"""### desc_Stockcode"""

# tampilkan data
data.head(2)

# jumlah karakter desc_stockcode yang berstatus duplikat dan tidak duplikat
(data['desc_stockcode']).value_counts()

# list jumlah tiap StockCode yang berstatus Duplicate dan UndupliCate
Code = data['desc_stockcode'].groupby(data['StockCode']).agg('value_counts').unstack()
Code

"""### year"""

# data jumlah transaksi tiap tahun
data['year'].agg('value_counts')

# data transaksi yang berstatus sukses dan gagal tiap tahunya
data['year'].groupby(data['Status_invoice']).agg('value_counts').unstack()

# data jumalh transaksi tiap negara ditiap tahunya
frequency = data['year'].groupby(data['Country']).agg('value_counts').unstack()
frequency = frequency.reset_index()
frequency.columns = ['Country', '2009', '2010', '2011']
frequency

# total barang / total kuantitas barang dalam transaksi tahun 2009 - 2011 
print('Total barang yang terjual dari tahun 2009 - 20011 yaitu : ', data['Quantity'].sum())
print('\njumlah barang(kuantitas) yang terjual tiap tahunya')

# jumlah barang(kuantitas) yang terjual tiap tahunya
quantity = data['Quantity'].groupby(data['year']).sum()
quantity

# total seluruh biaya transaksi pada tahun 2009-2011
data['sales'].groupby(data['year']).agg('sum')

"""### month"""

# banyaknya transakasi yang terjadi tiap bulanya
frequency=data['Invoice'].groupby(data['month']).agg('count')
frequency = frequency.reset_index()
frequency.columns = ['Month', 'Frequency']
frequency

# daftar frekuensi costumerID melakukan transakasi yang di tiap bulanya
data['month'].groupby(data['Customer ID']).agg('value_counts').unstack().head(5)

# jumlah transaksi dari tiap negara yang terjadi pada tiap bulanya
data['Country'].groupby(data['month']).agg('value_counts').unstack()

# jumlah transaksi yang berstaus sukses dan gagal ditiap bulanya
frequency = data['Status_invoice'].groupby(data['month']).agg('value_counts').unstack()
frequency = frequency.reset_index()
frequency.columns = ['Month', 'Failed', 'Succes']
frequency

# total biaya transaksi yang terjadi tiap bulanya
Amount=data['sales'].groupby(data['month']).agg('sum')
Amount = Amount.reset_index()
Amount.columns = ['Month', 'Amount']
Amount

"""### day"""

# jumlah transaksi yang berstaus sukses dan gagal ditiap bulanya
frequency = data['Status_invoice'].groupby(data['day']).agg('value_counts').unstack()
frequency = frequency.reset_index()
frequency.columns = ['day', 'Failed', 'Succes']
frequency

amount = data['sales'].groupby(data['day']).agg('sum')
amount = amount.reset_index()
amount.columns = ['Day', 'Amount']
amount

"""# SOLULUSI 1: Menggunakan Metode K-Means
Melakukan clustering dengan melihat waktu terakhir transaksi, frekuensi dan uang yang dikeluarkan saat transaksi terjadi.

### Analisis costumer
Analisis kontumer akan didasarkan pada :
1. R (Recency): Waktu terakhir melakukan transaksi
2. F (Frequency) : Banyaknya jumlah transaksi yang dilakukan
3. M (Monetary) : Total biaya transaksi

#### CostumerID
"""

# tampilkan data
data.head(2)

# frekuensi dari berbagai Costumer ID dalam melakukan transaksi
frequency=data['Invoice'].groupby(data['Customer ID']).agg('count')
frequency = frequency.reset_index()
frequency.columns = ['Customer ID', 'Frequency']
frequency.head()

# waktu terakhir transaksi dari berbagai Costumer ID 
time = data['time_difference'].groupby(data['Customer ID']).agg('min')
time = time.reset_index()
time.columns = ['Customer ID', 'Last Time']
time.head()

# total biaya transaksi dari berbagai Costumer ID 
amount = data['sales'].groupby(data['Customer ID']).agg('sum')
amount = amount.reset_index()
amount.columns = ['Customer ID', 'Total Amount']
amount.head()

# gabungkan tabel  amount dan frequency
costumer = pd.merge(amount, frequency, on='Customer ID', how='inner')
costumer

# gabungkan tabel  costumer dan time
costumer = pd.merge(costumer, time, on='Customer ID', how='inner')
costumer

"""### Analisis Country
Analisis kontumer akan didasarkan pada :
1. R (Recency): Waktu terakhir melakukan transaksi
2. F (Frequency) : Banyaknya jumlah transaksi yang dilakukan
3. M (Monetary) : Total biaya transaksi
"""

# frekuensi dari berbagai Negara dalam melakukan transaksi
frequency=data['Invoice'].groupby(data['Country']).agg('count')
frequency = frequency.reset_index()
frequency.columns = ['Country', 'Frequency']
frequency.head()

# waktu terakhir transaksi dari berbagai Negara 
time = data['time_difference'].groupby(data['Country']).agg('min')
time = time.reset_index()
time.columns = ['Country', 'Last Time']
time.head()

# total biaya transaksi dari berbagai Costumer ID 
amount = data['sales'].groupby(data['Country']).agg('sum')
amount = amount.reset_index()
amount.columns = ['Country', 'Total Amount']
amount.head()

# gabungkan tabel frequency dan time
country = pd.merge(frequency, time, on='Country', how='inner')
country

# gabungkan tabel costumer dan amount
country = pd.merge(country, amount, on='Country', how='inner')
country

"""## OUTLIER 
lihat outlier dari dataframe costumer dan country, mengecek outlier data dengan melihat boxplot.

### costumer
"""

# cek nama kolom costumer
costumer.columns

#  boxplot Total Amount untuk mendeteksi outlier dengan menggunakan whiskers pada 1.5

plt.boxplot(costumer["Total Amount"], notch=False, sym='.', vert=True, whis=1.5,
        positions=None, widths=None, patch_artist=False,
        bootstrap=None, usermedians=None, conf_intervals=None)

#  boxplot Total Amount untuk mendeteksi outlier dengan menggunakan whiskers pada 1.5

plt.boxplot(costumer["Frequency"], notch=False, sym='.', vert=True, whis=1.5,
        positions=None, widths=None, patch_artist=False,
        bootstrap=None, usermedians=None, conf_intervals=None)

#  boxplot Total Amount untuk mendeteksi outlier dengan menggunakan whiskers pada 1.5

plt.boxplot(costumer["Last Time"], notch=False, sym='.', vert=True, whis=1.5,
        positions=None, widths=None, patch_artist=False,
        bootstrap=None, usermedians=None, conf_intervals=None)

"""### country"""

# cek nama kolom country
country.columns

#  boxplot Total Frequency untuk mendeteksi outlier dengan menggunakan whiskers pada 1.5

plt.boxplot(country["Frequency"], notch=False, sym='.', vert=True, whis=1.5,
        positions=None, widths=None, patch_artist=False,
        bootstrap=None, usermedians=None, conf_intervals=None)

#  boxplot Total Last Time untuk mendeteksi outlier dengan menggunakan whiskers pada 1.5

plt.boxplot(country["Last Time"], notch=False, sym='.', vert=True, whis=1.5,
        positions=None, widths=None, patch_artist=False,
        bootstrap=None, usermedians=None, conf_intervals=None)

#  boxplot Total Frequency untuk mendeteksi outlier dengan menggunakan whiskers pada 1.5

plt.boxplot(country["Total Amount"], notch=False, sym='.', vert=True, whis=1.5,
        positions=None, widths=None, patch_artist=False,
        bootstrap=None, usermedians=None, conf_intervals=None)

"""## Scaling data costumer dan country
karena didalam beberapa kolom costumer dan country masih terdapat Outlier, maka data pada kolom tersebut akan di scaling untuk mengatasi outlier tersebut.
"""

# menampilkan nama kolom costumer
costumer.columns

"""#### Remove data costumer
remove data costumer yang berada diantara Q1 dan Q3
"""

# Total Amount

# hitung Quantil 1 dan 3
Q1 = costumer["Total Amount"].quantile(0.05)
Q3 = costumer["Total Amount"].quantile(0.95)
IQR = Q3 - Q1

# remove
costumer_new = costumer[(costumer["Total Amount"] >= Q1 - 1.5*IQR) & (costumer["Total Amount"] <= Q3 + 1.5*IQR)]

# ukuran costumer setelah diremove
costumer_new.shape

# Frequency

# hitung Quantil 1 dan 3
Q1 = costumer["Frequency"].quantile(0.05)
Q3 = costumer["Frequency"].quantile(0.95)
IQR = Q3 - Q1

# remove
costumer_new = costumer[(costumer["Frequency"] >= Q1 - 1.5*IQR) & (costumer["Frequency"] <= Q3 + 1.5*IQR)]

# ukuran costumer setelah diremove
costumer_new.shape

# Last Time

# hitung Quantil 1 dan 3
Q1 = costumer["Last Time"].quantile(0.05)
Q3 = costumer["Last Time"].quantile(0.95)
IQR = Q3 - Q1

# remove
costumer_new = costumer[(costumer["Last Time"] >= Q1 - 1.5*IQR) & (costumer["Last Time"] <= Q3 + 1.5*IQR)]

# ukuran costumer setelah diremove
costumer_new.shape

"""#### Remove data country
remove data country yang berada diantara Q1 dan Q3
"""

# Total Amount

# hitung Quantil 1 dan 3
Q1 = country["Total Amount"].quantile(0.05)
Q3 = country["Total Amount"].quantile(0.95)
IQR = Q3 - Q1

# remove
country_new = country[(country["Total Amount"] >= Q1 - 1.5*IQR) & (country["Total Amount"] <= Q3 + 1.5*IQR)]

# ukuran costumer setelah diremove
country_new.shape

# Frequency

# hitung Quantil 1 dan 3
Q1 = country["Frequency"].quantile(0.05)
Q3 = country["Frequency"].quantile(0.95)
IQR = Q3 - Q1

# remove
country_new = country[(country["Frequency"] >= Q1 - 1.5*IQR) & (country["Frequency"] <= Q3 + 1.5*IQR)]

# ukuran costumer setelah diremove
country_new.shape

# Last Time

# hitung Quantil 1 dan 3
Q1 = country["Last Time"].quantile(0.05)
Q3 = country["Last Time"].quantile(0.95)
IQR = Q3 - Q1

# remove
country_new = country[(country["Last Time"] >= Q1 - 1.5*IQR) & (country["Last Time"] <= Q3 + 1.5*IQR)]

# ukuran costumer setelah diremove
country_new.shape

"""#### Scaling costumer_new"""

costumer_new.columns

# list kolom yang akan di scaling
cos = costumer_new[['Total Amount', 'Frequency', 'Last Time']]

# scaling menggunakan standarscaler
scaler = StandardScaler()

# fit_transform
costumer_scale = scaler.fit_transform(cos)
costumer_scale.shape

"""####Scaling country_new"""

country_new.columns

# list kolom yang akan di scaling
coun = country_new[['Frequency', 'Last Time', 'Total Amount']]

# scaling menggunakan standarscaler
scaler = StandardScaler()

# fit_transform
country_scale = scaler.fit_transform(coun)
country_scale.shape



# buat data frame baru yang berisi data costumer_scale yang telah discaling
costumer_scale = pd.DataFrame(costumer_scale)
costumer_scale.columns = ['Amount', 'Frequency', 'Recency']
costumer_scale

# buat data frame baru yang berisi data country_scale yang telah discaling
country_scale = pd.DataFrame(country_scale)
country_scale.columns = ['Amount', 'Frequency', 'Recency']
country_scale

"""## MODELING Country
Metode K-Means Clustering berusaha mengelompokkan data yang ada ke dalam beberapa kelompok, dimana data dalam satu kelompok mempunyai karakteristik yang sama satu sama lainnya dan mempunyai karakteristik yang berbeda dengan data yang ada di dalam kelompok yang lain.

1. Data country akan diklasifikasikan menjadi 3 kluster dengan nilai 0,1,2
2. Evaluasi Klastering :
  * Metode Elbow, untuk melihat jumlah klustering yang optimal
  * Metode Silhouette, untuk melihat kualitas hasil klastering

#### Catatan :


*   negara dengan index klustering 0 berarti pelanggan yang berasal dari negara tersebut memiliki transaksi yang lebih tinggi dari pelanggan lain & masuk kedalam skala preoritas pertama.
*   negara dengan index klustering 1 berarti pelanggan yang berasal dari negara tersebut memiliki transaksi yang yang cukup & dapat dikatakan pelanggan tetap, serta masuk ke dalam skala preoritas kedua.
*   negara dengan index klustering 2 berarti pelanggan yang berasal dari negara tersebut memiliki transaksi yang sedikit dan masuk kedalam skala prioritas yang ketiga dalam segi bisnis kluster ini tidak terlalu penting.


"""

# k-means dengan beberapa kluster
kmeans = KMeans(n_clusters=4, max_iter=50)
kmeans.fit(country_scale)

# hasil kluster
kmeans.labels_

"""## Evaluasi klaster

### Metode Elbow
Metode Elbow adalah metode yang digunakan untuk pemilihan jumlah cluster (k) atau kluster yang optimal, dengan melihat sum of square error (SSE).
"""

# Evaluasi jumlah kluster metode Elbow
ssd = []

#  banyak kluster
range_n_clusters = [2, 3, 4, 5, 6, 7, 8]

# hitung sse untuk tiap n_cluster
for num_clusters in range_n_clusters:
    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)
    kmeans.fit(country_scale)
    ssd.append(kmeans.inertia_)
    
# plot sse 
plt.plot(ssd)

# panggil ssd, untuk mnapilkan nilai SSE
ssd

"""Dapat dilihat bahwa selisi nilai dari SSE yang dihasilkan yang terbesar dalah SSE untuk k=3 yaitu (42.78201844500861-6.95815310081544)= 35.82386534419317, sehingga dapat disimpulkan jumlah kluster yang baik adalah 3 atau k=3 dengan metode Elbow

### Metode Silhouette
Metode Silhouette digunakan dengan melihat Silhouette Coefficient yang digunakan untuk melihat kualitas dan kekuatan cluster, seberapa baik suatu objek ditempatkan dalam suatu cluster. metode ini bekerja dengan cara menghitung rata-rata dari keseluruan objek (a) dan dari rata-rata keseluruhan tersebut akan diambil rata-rata yang terkecil (b).
Rumus koefisien Silhouete :
Si= (bi – ai) / max(ai, bi)
"""

# Silhouette analysis
range_n_clusters = [2, 3, 4, 5, 6, 7, 8]

for num_clusters in range_n_clusters:
    
    # intialise kmeans
    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)
    kmeans.fit(country_scale)
    
    cluster_labels = kmeans.labels_
    
    # silhouette score
    silhouette_avg = silhouette_score(country_scale, cluster_labels)
    print("For n_clusters={0}, the silhouette score is {1}".format(num_clusters, silhouette_avg))

"""<p>Hasil klustering :</p>

1.   0.7 < (silhouette score) <= 1 Artinya : klasifikasi kuat
2.   0.5 < (silhouette score) <= 0.7 Artinya : klasifikasi medium
3.   0.25 < (silhouette score) <= 0.5 Artinya : klasifikasi lemah
4.   (silhouette score) <= 0.25     Artinya : tidak terklasifikasi

<p>Karena hasil klustering dengan menggunakan n_cluster sebanyak 3, dan dihasilkan nilai silhouette score nya yaitu 0.7813652642651966, maka dapat disimpulkan bahwa data country yang diklasifikasikan sebanyak 3 klustering kuat.</p>

### Hasil Clustering country
karena banyaknya klustering (n_clustering) yang optimal yaitu sebanyak 3 kluster dan nilai silhouette score yaitu 0.7813652642651966 dengan menggunakan n_clustering sebanyak 3 dikatakan kuat. Sehingga akan ditetapkan unuk data country akan diklasifikasikan menjadi 3 kluster.
"""

# klustering ahir menggunakan 3 kluster
kmeans = KMeans(n_clusters=3, max_iter=50)
kmeans.fit(country_scale)

# tampilkan hasil klustering
kmeans.labels_

# masukan hasil klustering ke tabel country
country['Clustering'] = kmeans.labels_
country.head()

# save tabel country
country.to_csv("Cluster_country.csv")

"""## MODELING Costumer
Metode K-Means Clustering berusaha mengelompokkan data yang ada ke dalam beberapa kelompok, dimana data dalam satu kelompok mempunyai karakteristik yang sama satu sama lainnya dan mempunyai karakteristik yang berbeda dengan data yang ada di dalam kelompok yang lain.

1. Data costumer akan diklasifikasikan menjadi 4 kluster dengan nilai 0,1,2,3
2. Evaluasi Klastering :
  * Metode Elbow, untuk melihat jumlah klustering yang optimal
  * Metode Silhouette, untuk melihat kualitas hasil klastering

#### Catatan :

*   pelanggan dengan index klustering 0 berarti pelanggan tersebut memiliki transaksi yang lebih tinggi dari pelanggan lain & masuk kedalam skala preoritas pertama.
*   pelanggan dengan index klustering 1 berarti pelanggan tersebut memiliki transaksi yang yang cukup & dapat dikatakan pelanggan tetap, serta masuk ke dalam skala preoritas kedua.
*   pelanggan dengan index klustering 2 berarti pelanggan tersebut memiliki transaksi yang sedikit dan masuk kedalam skala prioritas yang ketiga dalam segi bisnis kluster ini tidak terlalu penting.

"""

# k-means dengan beberapa kluster
kmeans = KMeans(n_clusters=4, max_iter=50)
kmeans.fit(costumer_scale)

# hasil kluster
kmeans.labels_

"""## Evaluasi klaster

### Metode Elbow
Metode Elbow adalah metode yang digunakan untuk pemilihan jumlah cluster (k) atau kluster yang optimal, dengan melihat sum of square error (SSE).
"""

# Evaluasi jumlah kluster metode Elbow
ssd = []

#  banyak kluster
range_n_clusters = [2, 3, 4, 5, 6, 7, 8]

# hitung sse untuk tiap n_cluster
for num_clusters in range_n_clusters:
    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)
    kmeans.fit(costumer_scale)
    ssd.append(kmeans.inertia_)
    
# plot sse 
plt.plot(ssd)

# panggil ssd, untuk mnapilkan nilai SSE
ssd

"""Dapat dilihat bahwa selisi nilai dari SSE yang dihasilkan yang terbesar adalah SSE untuk k=3 yaitu (6871.6533320268445 - 2058.4308104354973)= 4813.222521591348, sehingga dapat disimpulkan jumlah kluster yang baik adalah 3 atau k=3 dengan metode Elbow

### Metode Silhouette
Metode Silhouette digunakan dengan melihat Silhouette Coefficient yang digunakan untuk melihat kualitas dan kekuatan cluster, seberapa baik suatu objek ditempatkan dalam suatu cluster. metode ini bekerja dengan cara menghitung rata-rata dari keseluruan objek (a) dan dari rata-rata keseluruhan tersebut akan diambil rata-rata yang terkecil (b).
Rumus koefisien Silhouete :
Si= (bi – ai) / max(ai, bi)
"""

# Silhouette analysis
range_n_clusters = [2, 3, 4, 5, 6, 7, 8]

for num_clusters in range_n_clusters:
    
    # intialise kmeans
    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)
    kmeans.fit(costumer_scale)
    
    cluster_labels = kmeans.labels_
    
    # silhouette score
    silhouette_avg = silhouette_score(costumer_scale, cluster_labels)
    print("For n_clusters={0}, the silhouette score is {1}".format(num_clusters, silhouette_avg))

"""<p>Hasil klustering :</p>

1.   0.7 < (silhouette score) <= 1 Artinya : klasifikasi kuat
2.   0.5 < (silhouette score) <= 0.7 Artinya : klasifikasi medium
3.   0.25 < (silhouette score) <= 0.5 Artinya : klasifikasi lemah
4.   (silhouette score) <= 0.25     Artinya : tidak terklasifikasi



<p>Karena hasil klustering dengan menggunakan n_cluster sebanyak 3, dan dihasilkan nilai silhouette score nya yaitu 0.700935900384759, maka dapat disimpulkan bahwa data costumer yang diklasifikasikan sebanyak 3 klustering dapat dikatakan kuat.</p>

### Hasil Clustering country
karena banyaknya klustering (n_clustering) yang optimal yaitu sebanyak 3 kluster dan nilai silhouette score yaitu 0.700935900384759 dengan menggunakan n_clustering sebanyak 3 dikatakan kuat. Sehingga akan ditetapkan unuk data costumer akan diklasifikasikan menjadi 3 kluster.
"""

# klustering ahir menggunakan 3 kluster
kmeans = KMeans(n_clusters=3, max_iter=50)
kmeans.fit(costumer_scale)

# tampilkan hasil klustering
kmeans.labels_

# masukan hasil klustering ke tabel country
costumer['Clustering'] = kmeans.labels_
costumer.head()

# save tabel country
costumer.to_csv("Cluster_costumer.csv")

"""# SOLUSI 2 : Menggunakan tabel cohort

1. InvoiceMonth: Representasi string tahun dan bulan dari satu transaksi/faktur.

2. grouping : Representasi string dari tahun dan bulan pembelian pertama pelanggan. Label ini umum di semua faktur untuk pelanggan tertentu.

3. Periode kelompok / Indeks Kelompok:Sebuah bilangan bulat yang mewakili tahap pelanggan dalam "seumur hidup" -nya. Angka tersebut menunjukkan jumlah bulan yang telah berlalu sejak pembelian pertama.
"""

# buat kolom baru InvoiceMont untuk merepresentasikan tahun & bulan transaksi, namum tanggal transaksinya akan dibuat diawal bulan
def get_month(x) : return dt.datetime(x.year,x.month,1)
data['InvoiceMonth'] = data['InvoiceDate'].apply(get_month)

# tampilkan data
data.head(3)

# kelompokan Costumer ID berdasarkan InvoiceMonth
grouping = data.groupby('Customer ID')['InvoiceMonth']

# deskripsi grouping
grouping.describe()

# buat kolom baru cohortMonth yang berisi transformasi dari nilai minimum kolom InvoiceMonth 
data['CohortMonth'] = grouping.transform('min')
data.tail(5)

# buat fungsi untuk mengambil data nilai tahun, bulan dan hari(tanggal) dari kolom tertentu didalam dataframe
def get_month_int (data,column):
    year = data[column].dt.year
    month = data[column].dt.month
    day = data[column].dt.day
    return year, month , day

# definisikan variabel invoice_year dan invoice_month yang berisi nilai tahun dan tanggal transaksi dilakukan
invoice_year,invoice_month,_ = get_month_int(data,'InvoiceMonth')

#definisikan variabel cohort_year dan cohort_month yang berisi nilai tahun dan tanggal dari kolom CohortMonth
cohort_year,cohort_month,_ = get_month_int(data,'CohortMonth')

# definisikan variabel year_diff yang berisi selisi nilai antara invoice_year dan cohort_year
year_diff = invoice_year - cohort_year 

# definsikan variabel month_diff yang berisi selisi antara invoice_month dan cohort_month
month_diff = invoice_month - cohort_month

# buat kolom baru yang berisi
data['CohortIndex'] = year_diff * 12 + month_diff + 1 
data['CohortIndex']

# hitung pelanggan yang aktif tiap bulanya dari setiap kelompok
grouping = data.groupby(['CohortMonth', 'CohortIndex'])
cohort_data = grouping['Customer ID'].apply(pd.Series.nunique)

# buat tabel vivot yang indexnya berupa tiap unique didalam CohortMonth dan kolomnya berupa tiap unique didalam CohortIndex
cohort_data = cohort_data.reset_index()
cohort_counts = cohort_data.pivot(index='CohortMonth',columns='CohortIndex',values='Customer ID')
cohort_counts

"""### Tabel Retantion Rate 
Untuk melihat seberapa banyak jumlah pelanggan lama yang tetap membeli produk, maka akan digunakan tabel retantion.
"""

# ukuran tabel cohort_size
cohort_size = cohort_counts.iloc[:,0]

# hitung persentasi dari jumlah pelanggan lama yang tetap membeli produk tiap bulanya
retention = cohort_counts.divide(cohort_size,axis=0)
retention.round(3) * 100

# buat tabel heatmap tabel retantion
plt.figure(figsize=(15, 8))
plt.title('Retention rates')
sns.heatmap(data=retention,annot = True,fmt = '.0%',vmin = 0.0,vmax = 0.5,cmap="BuPu_r")
plt.show()

"""### Jumlah pelanggan yang tetap membeli ditiap kelompok dari tiap bulanya"""

# jumlah seluruh pelanggan yang tetap membeli produk tiap kelompok di tiap bulanya
grouping = data.groupby(['CohortMonth', 'CohortIndex'])
cohort_data = grouping['Quantity'].mean()
cohort_data = cohort_data.reset_index()

# buat tabel pivot dengan indeks CohortMonth dan kolom CohortIndex, serta dengan nilai Quantity
avg_quantity = cohort_data.pivot(index='CohortMonth',columns='CohortIndex',values='Quantity')
avg_quantity.round(1)
avg_quantity.index = avg_quantity.index.date
avg_quantity

# buat tabel heatmap dari tabel sum_quantity
plt.figure(figsize=(15, 8))
plt.title('Rata-rata Kuantitas Setiap kelompok Melakukan Transaksi Tiap Bulanya')
sns.heatmap(data=avg_quantity,annot = True,vmin = 0.0,vmax =20,cmap="BuGn_r")
plt.show()